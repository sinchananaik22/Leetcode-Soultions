class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack = [], []
        current = root
        
        while current or stack:
            # Reach the leftmost node
            while current:
                stack.append(current)
                current = current.left
            # Current is None, pop from stack
            current = stack.pop()
            res.append(current.val)
            # Visit right subtree
            current = current.right
        
        return res






          Example
# Tree: 1
#        \
#         2
#        /
#       3
# Inorder: [1,3,2]

Time & Space Complexity

Time → O(n) (visit all nodes)

Space → O(h) for recursion or stack (h = tree height)





or



# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)    # visit left subtree
            res.append(node.val)  # visit root
            inorder(node.right)   # visit right subtree
        
        inorder(root)
        return res

